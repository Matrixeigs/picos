

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Cut problems in graphs &mdash; picos 0.1.3 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="picos 0.1.3 documentation" href="index.html" />
    <link rel="up" title="Examples" href="examples.html" />
    <link rel="next" title="The PICOS Reference" href="api.html" />
    <link rel="prev" title="Examples from Optimal Experimental Design" href="optdes.html" /> 


  <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33037163-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

  </script>



  <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-33037163-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

  </script>

  </head>
<body><div class="admonition warning"><p class="first admonition-title">Warning</p><p class="last">You are consulting the doc of a former version of PICOS.The latest version is <a href="../index.html">HERE</a>. </p></div>    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api.html" title="The PICOS Reference"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="optdes.html" title="Examples from Optimal Experimental Design"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">PICOS</a> &raquo;</li>
          <li><a href="examples.html" accesskey="U">Examples</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="cut-problems-in-graphs">
<span id="graphs"></span><h1>Cut problems in graphs<a class="headerlink" href="#cut-problems-in-graphs" title="Permalink to this headline">¶</a></h1>
<p>The code below initializes the graph used in all the examples of this page.
It should be run prior to any of the codes presented in this page.
The packages <a class="reference external" href="http://networkx.lanl.gov/index.html">networkx</a>
and <a class="reference external" href="http://matplotlib.sourceforge.net">matplotlib</a>
are recquired.</p>
<p>We use an arbitrary graph generated by the LCF generator of the networkx package.
The graph is deterministic, so that we can run doctest and check
the output. We also use a kind of arbitrary sequence for the edge capacities.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">picos</span> <span class="kn">as</span> <span class="nn">pic</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>

<span class="c">#number of nodes</span>
<span class="n">N</span><span class="o">=</span><span class="mi">20</span>

<span class="c">#Generate a graph with LCF notation (you can change the values below to obtain another graph!)</span>
<span class="n">G</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">LCF_graph</span><span class="p">(</span><span class="n">N</span><span class="p">,[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">14</span><span class="p">],</span><span class="mi">5</span><span class="p">)</span>
<span class="n">G</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="c">#edges are bidirected</span>

<span class="c">#generate edge capacities</span>
<span class="n">c</span><span class="o">=</span><span class="p">{}</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()):</span>
        <span class="n">c</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">=</span><span class="p">((</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="mi">17</span> <span class="c">#an arbitrary sequence of numbers</span>
</pre></div>
</div>
<div class="section" id="max-flow-min-cut-lp">
<h2>Max-flow, Min-cut (LP)<a class="headerlink" href="#max-flow-min-cut-lp" title="Permalink to this headline">¶</a></h2>
<div class="section" id="max-flow">
<h3>Max-flow<a class="headerlink" href="#max-flow" title="Permalink to this headline">¶</a></h3>
<p>Given a directed graph <img class="math" src="_images/math/53654b401cac0a9ea8c12f91cddd56775f964e9c.png" alt="G(V,E)"/>,
with a capacity <img class="math" src="_images/math/60231b2990b31f4eb4f6668e09a2930f58924090.png" alt="c(e)"/> on each edge <img class="math" src="_images/math/035e03179f6f46dec9ccff6add1ffb999d17f465.png" alt="e \in E"/>,
a source node <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/> and a sink node <img class="math" src="_images/math/e0d2bf360290fd61d1c1557e763f2622363b3d35.png" alt="t"/>, the <strong>max-flow</strong> problem is
to find a flow from <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/> to <img class="math" src="_images/math/e0d2bf360290fd61d1c1557e763f2622363b3d35.png" alt="t"/> of maximum value. Recall that a flow
<img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/> to <img class="math" src="_images/math/e0d2bf360290fd61d1c1557e763f2622363b3d35.png" alt="t"/> is a mapping from <img class="math" src="_images/math/fa2fa899f0afb05d6837885523503a2d4df434f9.png" alt="E"/> to <img class="math" src="_images/math/ba48837cbe425e0a603921abb6d4be1caf212c15.png" alt="\mathbb{R}^+"/>
such that:</p>
<blockquote>
<div><ul class="simple">
<li>the capacity of each edge is respected: <img class="math" src="_images/math/a9ef91d463b62a5ae5c8b02d2d6c294bbad28142.png" alt="\forall e \in E,\ f(e) \leq c(e)"/></li>
<li>the flow is conserved at each non-terminal node:
<img class="math" src="_images/math/a3ffd60202fc88be17b4dd8bb6c1e90903ee74c5.png" alt="\forall n \in V \setminus \{s,t\},\ \sum_{(i,n)\in E} f((i,n)) = \sum_{(n,j)\in E} f((n,j))"/></li>
</ul>
</div></blockquote>
<p>Its value is defined as the volume passing from <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/> to <img class="math" src="_images/math/e0d2bf360290fd61d1c1557e763f2622363b3d35.png" alt="t"/>:</p>
<div class="math">
<p><img src="_images/math/b5ead614df1f0eb8ea1f1d64f277d1f6f1e31b66.png" alt="\mathrm{value} (f) = \sum_{(s,j)\in E} f((s,j)) - \sum_{(i,s)\in E} f((i,s)) = \sum_{(i,t)\in E} f((i,t)) - \sum_{(t,j)\in E} f((t,j))."/></p>
</div><p>This problem clearly has a linear programming formulation, which
we solve below for <tt class="docutils literal"><span class="pre">s=16</span></tt> and <tt class="docutils literal"><span class="pre">t=10</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">maxflow</span><span class="o">=</span><span class="n">pic</span><span class="o">.</span><span class="n">Problem</span><span class="p">()</span>
<span class="c">#source and sink nodes</span>
<span class="n">s</span><span class="o">=</span><span class="mi">16</span>
<span class="n">t</span><span class="o">=</span><span class="mi">10</span>

<span class="c">#convert the capacities as a picos expression</span>
<span class="n">cc</span><span class="o">=</span><span class="n">pic</span><span class="o">.</span><span class="n">new_param</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>

<span class="c">#flow variable</span>
<span class="n">f</span><span class="o">=</span><span class="p">{}</span>
<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">f</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">=</span><span class="n">maxflow</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s">&#39;f[{0}]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>


<span class="c">#flow value</span>
<span class="n">F</span><span class="o">=</span><span class="n">maxflow</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s">&#39;F&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="c">#upper bound on the flows</span>
<span class="n">maxflow</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
        <span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">&lt;</span><span class="n">cc</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()],</span> <span class="c">#list of constraints</span>
        <span class="p">[(</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span>                       <span class="c">#e is a double index (start and end node of the edges)</span>
        <span class="s">&#39;edges&#39;</span>                          <span class="c">#set the index belongs to</span>
        <span class="p">)</span>

<span class="c">#flow conservation</span>
<span class="n">maxflow</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
<span class="p">[</span>   <span class="n">pic</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span><span class="s">&#39;p&#39;</span><span class="p">,</span><span class="s">&#39;pred(i)&#39;</span><span class="p">)</span>
<span class="o">==</span> <span class="n">pic</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">i</span><span class="p">)],</span><span class="s">&#39;j&#39;</span><span class="p">,</span><span class="s">&#39;succ(i)&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)],</span>
        <span class="s">&#39;i&#39;</span><span class="p">,</span><span class="s">&#39;nodes-(s,t)&#39;</span><span class="p">)</span>

<span class="c">#source flow at s</span>
<span class="n">maxflow</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span>
<span class="n">pic</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">s</span><span class="p">)],</span><span class="s">&#39;p&#39;</span><span class="p">,</span><span class="s">&#39;pred(s)&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">F</span>
<span class="o">==</span> <span class="n">pic</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="n">s</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">s</span><span class="p">)],</span><span class="s">&#39;j&#39;</span><span class="p">,</span><span class="s">&#39;succ(s)&#39;</span><span class="p">)</span>
<span class="p">)</span>

<span class="c">#sink flow at t</span>
<span class="n">maxflow</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span>
<span class="n">pic</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">predecessors</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span><span class="s">&#39;p&#39;</span><span class="p">,</span><span class="s">&#39;pred(t)&#39;</span><span class="p">)</span>
<span class="o">==</span> <span class="n">pic</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="n">t</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">t</span><span class="p">)],</span><span class="s">&#39;j&#39;</span><span class="p">,</span><span class="s">&#39;succ(t)&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">F</span>
<span class="p">)</span>

<span class="c">#nonnegativity of the flows</span>
<span class="n">maxflow</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
        <span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()],</span>    <span class="c">#list of constraints</span>
        <span class="p">[(</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span>                      <span class="c">#e is a double index (origin and desitnation of the edges)</span>
        <span class="s">&#39;edges&#39;</span>                         <span class="c">#set the index belongs to</span>
        <span class="p">)</span>

<span class="c">#objective</span>
<span class="n">maxflow</span><span class="o">.</span><span class="n">set_objective</span><span class="p">(</span><span class="s">&#39;max&#39;</span><span class="p">,</span><span class="n">F</span><span class="p">)</span>

<span class="c">#solve the problem</span>
<span class="k">print</span> <span class="n">maxflow</span>
<span class="n">maxflow</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;The optimal flow has value {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>---------------------
optimization problem  (LP):
61 variables, 140 affine constraints

f   : dict of 60 variables, (1, 1), continuous
F   : (1, 1), continuous

        maximize F
such that
f[e] &lt; c[e] for all e in edges
Σ_{p in pred(i)} f[(p, i)] = Σ_{j in succ(i)} f[(i, j)] for all i in nodes-(s,t)
Σ_{p in pred(s)} f[(p, 16)] + F = Σ_{j in succ(s)} f[(16, j)]
Σ_{p in pred(t)} f[(p, 10)] = Σ_{j in succ(t)} f[(10, j)] + F
f[e] &gt; 0 for all e in edges
---------------------
The optimal flow has value 15.0
</pre></div>
</div>
<p>Let us now draw the maximum flow:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#display the graph</span>
<span class="kn">import</span> <span class="nn">pylab</span>
<span class="n">fig</span><span class="o">=</span><span class="n">pylab</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>

<span class="n">node_colors</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;w&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">N</span>
<span class="n">node_colors</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="s">&#39;g&#39;</span> <span class="c">#source is green</span>
<span class="n">node_colors</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="s">&#39;b&#39;</span> <span class="c">#sink is blue</span>

<span class="n">pos</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="c">#edges</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">edgelist</span><span class="o">=</span><span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">node_color</span><span class="o">=</span><span class="n">node_colors</span><span class="p">)</span>


<span class="n">labels</span><span class="o">=</span><span class="p">{</span><span class="n">e</span><span class="p">:</span><span class="s">&#39;{0}/{1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="n">e</span><span class="p">],</span><span class="n">c</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">f</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">}</span>
<span class="c">#flow label</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edge_labels</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span>
                        <span class="n">edge_labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>

<span class="c">#hide axis</span>
<span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
<span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>

<span class="n">pylab</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="./pyplots/maxflow.py">Source code</a>, <a class="reference external" href="./pyplots/maxflow.png">png</a>, <a class="reference external" href="./pyplots/maxflow.hires.png">hires.png</a>, <a class="reference external" href="./pyplots/maxflow.pdf">pdf</a>)</p>
<div class="figure">
<img alt="_images/maxflow.png" src="_images/maxflow.png" />
</div>
<p>The graph shows the source in blue, the sink in green,
and the value of the flow together with the capacity on each edge.</p>
</div>
<div class="section" id="min-cut">
<h3>Min-cut<a class="headerlink" href="#min-cut" title="Permalink to this headline">¶</a></h3>
<p>Given a directed graph <img class="math" src="_images/math/53654b401cac0a9ea8c12f91cddd56775f964e9c.png" alt="G(V,E)"/>,
with a capacity <img class="math" src="_images/math/60231b2990b31f4eb4f6668e09a2930f58924090.png" alt="c(e)"/> on each edge <img class="math" src="_images/math/035e03179f6f46dec9ccff6add1ffb999d17f465.png" alt="e \in E"/>,
a source node <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/> and a sink node <img class="math" src="_images/math/e0d2bf360290fd61d1c1557e763f2622363b3d35.png" alt="t"/>, the <strong>min-cut</strong> problem is
to find a partition of the nodes in two sets <img class="math" src="_images/math/46e7ae1f57785a72342e86ee7dbe86cd7c43bd68.png" alt="(S,T)"/>, such that
<img class="math" src="_images/math/44785f09e8270acafc2f0beb66f0517981a36529.png" alt="s\in S"/>, <img class="math" src="_images/math/de4dd7c3b9228b9fc434b8a85ca63bfc094f971c.png" alt="t \in T"/>, and the total capacity of the cut,
<img class="math" src="_images/math/a6e48461a63e835d60db5ec199d901c5ea4d573b.png" alt="\mathrm{capacity}(S,T)=\sum_{(i,j)\in E \cap S \times T} c((i,j)),"/> is minimized.</p>
<p>It can be seen that binary solutions <img class="math" src="_images/math/9df68fe44cf5413883076e1acaba0102dce9551c.png" alt="d\in\{0,1\}^E,\ p\in\{0,1\}^V"/>
of the following linear program yield a minimum cut:</p>
<div class="math">
<p><img src="_images/math/08cc89c84bdea19f40253477e3644d2be147ddd5.png" alt="\begin{center}
\begin{eqnarray*}
&amp;\underset{\substack{d \in \mathbb{R}^E\\
                          p \in \mathbb{R}^V}}
             {\mbox{minimize}}
                   &amp; \sum_{e \in E} c(e) d(e)\\
&amp;\mbox{subject to} &amp; \forall (i,j) \in E,\ d((i,j)) \geq p(i)-p(j)\\
&amp;                  &amp; p(s) = 1\\
&amp;                  &amp; p(t) = 0\\
&amp;                  &amp; \forall n \in V,\ p(n) \geq 0\\
&amp;                  &amp; \forall e \in E,\ d(e) \geq 0
\end{eqnarray*}
\end{center}"/></p>
</div><p>Remarkably, this LP is the dual of the max-flow LP, and the
max-flow-min-cut theorem (also known as Ford-Fulkerson theorem <a class="reference internal" href="#graph-refs"><em>[1]</em></a>)
states that the capacity of the minimum cut is equal to the
value of the maximum flow. This means that the above LP always has
an optimal solution in which <img class="math" src="_images/math/96ab646de7704969b91c76a214126b45f2b07b25.png" alt="d"/> is binary.
In fact, the matrix defining this LP is <em>totally unimodular</em>, from
which we know that every extreme point of the polyhedron defining the
feasible region is integral, and hence the simplex algorithm
will return a minimum cut.</p>
<p>We solve the mincut problem below, for <tt class="docutils literal"><span class="pre">s=16</span></tt> and <tt class="docutils literal"><span class="pre">t=10</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mincut</span><span class="o">=</span><span class="n">pic</span><span class="o">.</span><span class="n">Problem</span><span class="p">()</span>

<span class="c">#source and sink nodes</span>
<span class="n">s</span><span class="o">=</span><span class="mi">16</span>
<span class="n">t</span><span class="o">=</span><span class="mi">10</span>

<span class="c">#convert the capacities as a picos expression</span>
<span class="n">cc</span><span class="o">=</span><span class="n">pic</span><span class="o">.</span><span class="n">new_param</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>

<span class="c">#cut variable</span>
<span class="n">d</span><span class="o">=</span><span class="p">{}</span>
<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">=</span><span class="n">mincut</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s">&#39;d[{0}]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="mi">1</span><span class="p">)</span>

<span class="c">#potentials</span>
<span class="n">p</span><span class="o">=</span><span class="n">mincut</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s">&#39;p&#39;</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>

<span class="c">#potential inequalities</span>
<span class="n">mincut</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
        <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()],</span>        <span class="c">#list of constraints</span>
        <span class="p">[</span><span class="s">&#39;i&#39;</span><span class="p">,</span><span class="s">&#39;j&#39;</span><span class="p">],</span><span class="s">&#39;edges&#39;</span><span class="p">)</span>              <span class="c">#indices and set they belong to</span>

<span class="c">#one-potential at source</span>
<span class="n">mincut</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
<span class="c">#zero-potential at sink</span>
<span class="n">mincut</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span>

<span class="c">#nonnegativity</span>
<span class="n">mincut</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">p</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
<span class="n">mincut</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
        <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()],</span>    <span class="c">#list of constraints</span>
        <span class="p">[(</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span>                      <span class="c">#e is a double index (origin and desitnation of the edges)</span>
        <span class="s">&#39;edges&#39;</span>                         <span class="c">#set the index belongs to</span>
        <span class="p">)</span>

<span class="c">#objective</span>
<span class="n">mincut</span><span class="o">.</span><span class="n">set_objective</span><span class="p">(</span><span class="s">&#39;min&#39;</span><span class="p">,</span>
                <span class="n">pic</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">cc</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">*</span><span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()],</span>
                        <span class="p">[(</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span><span class="s">&#39;edges&#39;</span><span class="p">)</span>
                <span class="p">)</span>

<span class="k">print</span> <span class="n">mincut</span>
<span class="n">mincut</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;The minimal cut has capacity {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mincut</span><span class="o">.</span><span class="n">obj_value</span><span class="p">())</span>

<span class="n">cut</span><span class="o">=</span><span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span>
<span class="n">S</span>  <span class="o">=</span><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span>
<span class="n">T</span>  <span class="o">=</span><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>

<span class="k">print</span> <span class="s">&#39;the partition of the nodes is: &#39;</span>
<span class="k">print</span> <span class="s">&#39;S: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;T: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>---------------------
optimization problem  (LP):
80 variables, 142 affine constraints

d   : dict of 60 variables, (1, 1), continuous
p   : (20, 1), continuous

        minimize Σ_{e in edges} c[e]*d[e]
such that
d[(i, j)] &gt; p[i] -p[j] for all (i,j) in edges
p[16] = 1.0
p[10] = 0
p &gt; |0|
d[e] &gt; 0 for all e in edges
---------------------
The minimal cut has capacity 15.0
the partition of the nodes is:
S: [15, 16, 17, 18]
T: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 19]
</pre></div>
</div>
<p>Note that the minimum-cut could also habe been found by using the dual variables
of the maxflow LP:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c">#capacited flow constraint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">capaflow</span><span class="o">=</span><span class="n">maxflow</span><span class="o">.</span><span class="n">get_constraint</span><span class="p">((</span><span class="mi">0</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dualcut</span><span class="o">=</span><span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span> <span class="k">if</span> <span class="n">capaflow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dual</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#flow conservation constraint</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">consflow</span><span class="o">=</span><span class="n">maxflow</span><span class="o">.</span><span class="n">get_constraint</span><span class="p">((</span><span class="mi">1</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sdual</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">+</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span>
<span class="gp">... </span>          <span class="nb">enumerate</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)])</span>
<span class="gp">... </span>          <span class="k">if</span> <span class="n">consflow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dual</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Tdual</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">+</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span>
<span class="gp">... </span>          <span class="nb">enumerate</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)])</span>
<span class="gp">... </span>          <span class="k">if</span> <span class="n">consflow</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">dual</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cut</span> <span class="o">==</span> <span class="n">dualcut</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">set</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">Sdual</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">set</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">Tdual</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Let us now draw the maximum flow:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pylab</span>
<span class="n">fig</span><span class="o">=</span><span class="n">pylab</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>

<span class="n">node_colors</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;w&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">N</span>
<span class="n">node_colors</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="s">&#39;g&#39;</span> <span class="c">#source is green</span>
<span class="n">node_colors</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="s">&#39;b&#39;</span> <span class="c">#sink is blue</span>

<span class="n">pos</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="c">#edges (not in the cut)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">edgelist</span><span class="o">=</span><span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cut</span><span class="p">],</span>
                <span class="n">node_color</span><span class="o">=</span><span class="n">node_colors</span><span class="p">)</span>

<span class="c">#edges of the cut</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">edgelist</span><span class="o">=</span><span class="n">cut</span><span class="p">,</span>
                <span class="n">edge_color</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">)</span>

<span class="c">#hide axis</span>
<span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
<span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>

<span class="n">pylab</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="./pyplots/mincut.py">Source code</a>, <a class="reference external" href="./pyplots/mincut.png">png</a>, <a class="reference external" href="./pyplots/mincut.hires.png">hires.png</a>, <a class="reference external" href="./pyplots/mincut.pdf">pdf</a>)</p>
<div class="figure">
<img alt="_images/mincut.png" src="_images/mincut.png" />
</div>
<p>On this graph, the source in blue, the sink in green,
and the edges defining the cut are marked in red.</p>
</div>
</div>
<div class="section" id="multicut-mip">
<h2>Multicut (MIP)<a class="headerlink" href="#multicut-mip" title="Permalink to this headline">¶</a></h2>
<p>Multicut is a generalization of the mincut problem, in which several pairs
of nodes must be disconnected. The goal is to find a cut of minimal
capacity, such that for all pair <img class="math" src="_images/math/770fc4aefd5d511759ef15ab08a9afd28b42800e.png" alt="(s,t) \in \mathcal{P}=\{(s_1,t_1),\ldots,(s_k,t_k))\}"/>,
there is no path from <img class="math" src="_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/> to <cite>t</cite> in the graph where the edges of the cut
have been removed.</p>
<p>We can obtain a MIP formulation of the multicut problem
by doing a small modification the <em>mincut</em> LP.
The idea is to introduce a different potential for every node
which is the source of a pair in <img class="math" src="_images/math/74f4008768812f46db4b252c9e69cf98c5faaa4b.png" alt="\mathcal{P}"/>:</p>
<div class="math">
<p><img src="_images/math/06acf47e50e768a09f2c2b8247436c0ffda5a3a6.png" alt="\forall s \in \mathcal{S}=\{s\in V: \exists t \in V\ (s,t)\in\mathcal{P}\},
p_s \in \mathbb{R}^V,"/></p>
</div><p>and to force the cut variable to be binary.</p>
<div class="math">
<p><img src="_images/math/f702ef29dc76591c032c583eff6b81deca3b564b.png" alt="\begin{center}
\begin{eqnarray*}
&amp;\underset{\substack{y \in \{0,1\}^E\\
                     \forall s \in \mathcal{S},\ p_s \in \mathbb{R}^V}}
             {\mbox{minimize}}
                   &amp; \sum_{e \in E} c(e) y(e)\\
&amp;\mbox{subject to} &amp; \forall (i,j),s \in E\times\mathcal{S},\ y((i,j)) \geq p_s(i)-p_s(j)\\
&amp;                  &amp; \forall s \in \mathcal{S},\ p_s(s) = 1\\
&amp;                  &amp; \forall (s,t) \in \mathcal{P},\ p_s(t) = 0\\
&amp;                  &amp; \forall (s,n) \in \mathcal{S} \times V,\ p_s(n) \geq 0
\end{eqnarray*}
\end{center}"/></p>
</div><p>Unlike the mincut problem, the LP obtained by relaxing the integer constraint
<img class="math" src="_images/math/536651be189729d5088e89472d611e3a335c46d7.png" alt="y \in \{0,1\}^E"/> is not guaranteed to have an integral solution (see e.g. <a class="reference internal" href="#graph-refs"><em>[2]</em></a>).
We solve the multicut problem below, for the terminal pairs
<img class="math" src="_images/math/ce7f4f7ed2ac2a4bad2ae4b93a29ad699b08119c.png" alt="\mathcal{P}=\{(0,12),(1,5),(1,19),(2,11),(3,4),(3,9),(3,18),(6,15),(10,14)\}"/>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">multicut</span><span class="o">=</span><span class="n">pic</span><span class="o">.</span><span class="n">Problem</span><span class="p">()</span>

<span class="c">#pairs to be separated</span>
<span class="n">pairs</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">12</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">19</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">11</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">18</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">15</span><span class="p">),(</span><span class="mi">10</span><span class="p">,</span><span class="mi">14</span><span class="p">)]</span>

<span class="c">#source and sink nodes</span>
<span class="n">s</span><span class="o">=</span><span class="mi">16</span>
<span class="n">t</span><span class="o">=</span><span class="mi">10</span>

<span class="c">#convert the capacities as a picos expression</span>
<span class="n">cc</span><span class="o">=</span><span class="n">pic</span><span class="o">.</span><span class="n">new_param</span><span class="p">(</span><span class="s">&#39;c&#39;</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>

<span class="c">#list of sources</span>
<span class="n">sources</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">])</span>


<span class="c">#cut variable</span>
<span class="n">y</span><span class="o">=</span><span class="p">{}</span>
<span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">y</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">=</span><span class="n">multicut</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s">&#39;y[{0}]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="mi">1</span><span class="p">,</span><span class="n">vtype</span><span class="o">=</span><span class="s">&#39;binary&#39;</span><span class="p">)</span>

<span class="c">#potentials (one for each source)</span>
<span class="n">p</span><span class="o">=</span><span class="p">{}</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">:</span>
        <span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="n">multicut</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s">&#39;p[{0}]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">),</span><span class="n">N</span><span class="p">)</span>

<span class="c">#potential inequalities</span>
<span class="n">multicut</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
        <span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">&gt;</span><span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sources</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()],</span>        <span class="c">#list of constraints</span>
        <span class="p">[</span><span class="s">&#39;i&#39;</span><span class="p">,</span><span class="s">&#39;j&#39;</span><span class="p">,</span><span class="s">&#39;s&#39;</span><span class="p">],</span><span class="s">&#39;edges x sources&#39;</span><span class="p">)</span><span class="c">#indices and set they belong to</span>

<span class="c">#one-potentials at source</span>
<span class="n">multicut</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
        <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">s</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">],</span>
        <span class="s">&#39;s&#39;</span><span class="p">,</span><span class="s">&#39;sources&#39;</span><span class="p">)</span>

<span class="c">#zero-potentials at sink</span>
<span class="n">multicut</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
        <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">t</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span> <span class="k">for</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">],</span>
        <span class="p">[</span><span class="s">&#39;s&#39;</span><span class="p">,</span><span class="s">&#39;t&#39;</span><span class="p">],</span><span class="s">&#39;pairs&#39;</span><span class="p">)</span>

<span class="c">#nonnegativity</span>
<span class="n">multicut</span><span class="o">.</span><span class="n">add_list_of_constraints</span><span class="p">(</span>
        <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sources</span><span class="p">],</span>
        <span class="s">&#39;s&#39;</span><span class="p">,</span><span class="s">&#39;sources&#39;</span><span class="p">)</span>

<span class="c">#objective</span>
<span class="n">multicut</span><span class="o">.</span><span class="n">set_objective</span><span class="p">(</span><span class="s">&#39;min&#39;</span><span class="p">,</span>
                <span class="n">pic</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">cc</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">*</span><span class="n">y</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()],</span>
                        <span class="p">[(</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">)],</span><span class="s">&#39;edges&#39;</span><span class="p">)</span>
                <span class="p">)</span>

<span class="k">print</span> <span class="n">multicut</span>
<span class="n">multicut</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;The minimal multicut has capacity {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">multicut</span><span class="o">.</span><span class="n">obj_value</span><span class="p">())</span>

<span class="n">cut</span><span class="o">=</span><span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span>

<span class="k">print</span> <span class="s">&#39;The edges forming the cut are: &#39;</span>
<span class="k">print</span> <span class="n">cut</span>
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>---------------------
optimization problem  (MIP):
180 variables, 495 affine constraints

y   : dict of 60 variables, (1, 1), binary
p   : dict of 6 variables, (20, 1), continuous

        minimize Σ_{e in edges} c[e]*y[e]
such that
y[(i, j)] &gt; p[s][i] -p[s][j] for all (i,j,s) in edges x sources
p[s][s] = 1.0 for all s in sources
p[s][t] = 0 for all (s,t) in pairs
p[s] &gt; |0| for all s in sources
---------------------
The minimal multicut has capacity 49.0
The edges forming the cut are:
[(1, 0), (1, 4), (2, 16),
 (2, 8), (3, 4), (5, 11),
 (7, 8), (9, 8), (10, 11),
 (13, 16), (13, 12),
 (13, 14), (17, 16)]
</pre></div>
</div>
<p>Let us now draw the multicut:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pylab</span>

<span class="n">fig</span><span class="o">=</span><span class="n">pylab</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>

<span class="c">#pairs of dark and light colors</span>
<span class="n">colors</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;Yellow&#39;</span><span class="p">,</span><span class="s">&#39;#FFFFE0&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;#888888&#39;</span><span class="p">,</span><span class="s">&#39;#DDDDDD&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;Dodgerblue&#39;</span><span class="p">,</span><span class="s">&#39;Aqua&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;DarkGreen&#39;</span><span class="p">,</span><span class="s">&#39;GreenYellow&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;DarkViolet&#39;</span><span class="p">,</span><span class="s">&#39;Violet&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;SaddleBrown&#39;</span><span class="p">,</span><span class="s">&#39;Peru&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;Red&#39;</span><span class="p">,</span><span class="s">&#39;Tomato&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&#39;DarkGoldenRod&#39;</span><span class="p">,</span><span class="s">&#39;Gold&#39;</span><span class="p">),</span>
        <span class="p">]</span>

<span class="n">node_colors</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;w&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">N</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sources</span><span class="p">):</span>
        <span class="n">node_colors</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="p">(</span><span class="n">s0</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="n">pairs</span> <span class="k">if</span> <span class="n">s0</span><span class="o">==</span><span class="n">s</span><span class="p">]:</span>
                <span class="n">node_colors</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

<span class="n">pos</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">edgelist</span><span class="o">=</span><span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cut</span><span class="p">],</span>
                <span class="n">node_color</span><span class="o">=</span><span class="n">node_colors</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">edgelist</span><span class="o">=</span><span class="n">cut</span><span class="p">,</span>
                <span class="n">edge_color</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">)</span>

<span class="c">#hide axis</span>
<span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
<span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>

<span class="n">pylab</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="./pyplots/multicut.py">Source code</a>, <a class="reference external" href="./pyplots/multicut.png">png</a>, <a class="reference external" href="./pyplots/multicut.hires.png">hires.png</a>, <a class="reference external" href="./pyplots/multicut.pdf">pdf</a>)</p>
<div class="figure">
<img alt="_images/multicut.png" src="_images/multicut.png" />
</div>
<p>On this graph, the pairs of terminal nodes are denoted by
dark and light colors of the same shade (e.g. dark vs. light green
for the pairs (3,4),(3,9), and (3,18)), and the edges defining the
cut are marked in red.</p>
</div>
<div class="section" id="maxcut-relaxation-sdp">
<h2>Maxcut relaxation (SDP)<a class="headerlink" href="#maxcut-relaxation-sdp" title="Permalink to this headline">¶</a></h2>
<p>The goal of the <strong>maxcut</strong> problem is to find
a partition (S,T) of the nodes of an <em>undirected</em> graph G(V,E),
such that the capacity of the cut,
<img class="math" src="_images/math/0ff86250244d339d301e1531f4883dbab401cb53.png" alt="\mathrm{capacity}(S,T)=\sum_{\{i,j\} \in E \cap (S \Delta T)} c((i,j)),"/>
is maximized.</p>
<p>Goemans and Williamson have designed a famous 0.878-approximation
algorithm <a class="reference internal" href="#graph-refs"><em>[3]</em></a> for this NP-hard problem based on semidefinite programming.
The idea is to introduce a variable <img class="math" src="_images/math/4df336e82fd511be8f09b20d495766f975031ff3.png" alt="x \in \{-1,1\}^V"/> where
<img class="math" src="_images/math/b056ceaea9b9802c449700bc5df2c30f4463987c.png" alt="x(n)"/> takes the value +1 or -1 depending on wheter <img class="math" src="_images/math/69f2f47d28b4bb43333d96cbb480ed70f7989406.png" alt="n \in S"/>
or <img class="math" src="_images/math/cbcf542abd108a2c2ce0cca5b7898d19433a2bfa.png" alt="n \in T"/>. Then, it can be seen that the value of the cut
is equal to <img class="math" src="_images/math/7350f84748e86eb3a82f456a63b703bc6dbcc1a6.png" alt="\frac{1}{4} x^T L x"/>, where <img class="math" src="_images/math/859ccf4cd60c7bc6b8fa1afc9a42dc811a826d6f.png" alt="L"/> is the Laplacian
of the graph. If we define the matrix <img class="math" src="_images/math/68e5702d7dd8a5616497a873e03f2f21654e62a5.png" alt="X=xx^T"/>, which is positive
semidefinite of rank 1, we obtain an SDP by relaxing the
rank-one constraint on <img class="math" src="_images/math/6a47ca0fe7cb276abc022af6ac88ddae1a9d6894.png" alt="X"/> :</p>
<div class="math">
<p><img src="_images/math/93c7561eb887f4c63aabb9648101eabaf6acc077.png" alt="\begin{center}
\begin{eqnarray*}
&amp;\underset{X \in \mathbb{S}_{|V|}}
             {\mbox{maximize}}
                   &amp; \frac{1}{4} \langle L, X \rangle \\
&amp;\mbox{subject to} &amp; \mbox{diag}(X) = \mathbf{1}\\
&amp;                  &amp; X \succeq 0
\end{eqnarray*}
\end{center}"/></p>
</div><p>Then, Goemans and Williamson have shown that if we project the solution <img class="math" src="_images/math/6a47ca0fe7cb276abc022af6ac88ddae1a9d6894.png" alt="X"/>
onto a random hyperplan, we obtain a cut whose expected capacity is at least
0.878 times the optimum. Below is a simple implementation of their algorithm:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">cvxopt</span> <span class="kn">as</span> <span class="nn">cvx</span>
<span class="kn">import</span> <span class="nn">cvxopt.lapack</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="c">#make G undirected</span>
<span class="n">G</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

<span class="c">#allocate weights to the edges</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
        <span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="s">&#39;weight&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span>


<span class="n">maxcut</span> <span class="o">=</span> <span class="n">pic</span><span class="o">.</span><span class="n">Problem</span><span class="p">()</span>
<span class="n">X</span><span class="o">=</span><span class="n">maxcut</span><span class="o">.</span><span class="n">add_variable</span><span class="p">(</span><span class="s">&#39;X&#39;</span><span class="p">,(</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="s">&#39;symmetric&#39;</span><span class="p">)</span>

<span class="c">#Laplacian of the graph</span>
<span class="n">L</span><span class="o">=</span><span class="n">pic</span><span class="o">.</span><span class="n">new_param</span><span class="p">(</span><span class="s">&#39;L&#39;</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mf">4.</span><span class="o">*</span><span class="n">nx</span><span class="o">.</span><span class="n">laplacian</span><span class="p">(</span><span class="n">G</span><span class="p">))</span>

<span class="c">#ones on the diagonal</span>
<span class="n">maxcut</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">pic</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">diag_vect</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
<span class="c">#X positive semidefinite</span>
<span class="n">maxcut</span><span class="o">.</span><span class="n">add_constraint</span><span class="p">(</span><span class="n">X</span><span class="o">&gt;&gt;</span><span class="mi">0</span><span class="p">)</span>

<span class="c">#objective</span>
<span class="n">maxcut</span><span class="o">.</span><span class="n">set_objective</span><span class="p">(</span><span class="s">&#39;max&#39;</span><span class="p">,</span><span class="n">L</span><span class="o">|</span><span class="n">X</span><span class="p">)</span>

<span class="k">print</span> <span class="n">maxcut</span>
<span class="n">maxcut</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;bound from the SDP relaxation: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">maxcut</span><span class="o">.</span><span class="n">obj_value</span><span class="p">())</span>

<span class="c">#---------------------------#</span>
<span class="c">#RANDOM PROJECTION ALGORITHM#</span>
<span class="c">#---------------------------#</span>

<span class="c">#Cholesky factorization</span>
<span class="n">V</span><span class="o">=</span><span class="n">X</span><span class="o">.</span><span class="n">value</span>

<span class="n">cvxopt</span><span class="o">.</span><span class="n">lapack</span><span class="o">.</span><span class="n">potrf</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
                <span class="n">V</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>

<span class="c">#random projection algorithm</span>
<span class="c">#Repeat 100 times or until we are within a factor .878 of the SDP optimal value</span>
<span class="n">count</span><span class="o">=</span><span class="mi">0</span>
<span class="n">obj_sdp</span><span class="o">=</span><span class="n">maxcut</span><span class="o">.</span><span class="n">obj_value</span><span class="p">()</span>
<span class="n">obj</span><span class="o">=</span><span class="mi">0</span>
<span class="k">while</span> <span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span><span class="mi">100</span> <span class="ow">or</span> <span class="n">obj</span><span class="o">&lt;.</span><span class="mi">878</span><span class="o">*</span><span class="n">obj_sdp</span><span class="p">):</span>
        <span class="n">r</span><span class="o">=</span><span class="n">cvx</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span><span class="o">=</span><span class="n">cvx</span><span class="o">.</span><span class="n">matrix</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">V</span><span class="o">*</span><span class="n">r</span><span class="p">))</span>
        <span class="n">o</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">&gt;</span><span class="n">obj</span><span class="p">:</span>
                <span class="n">x_cut</span><span class="o">=</span><span class="n">x</span>
                <span class="n">obj</span><span class="o">=</span><span class="n">o</span>
        <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>

<span class="k">print</span> <span class="s">&#39;value of the cut: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="n">S1</span><span class="o">=</span><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span>
<span class="n">S2</span><span class="o">=</span><span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
<span class="n">cut</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span>

<span class="c">#we comment this because the output in unpredicatable for doctest:</span>
<span class="c">#print &#39;partition of the nodes:&#39;</span>
<span class="c">#print &#39;S1: {0}&#39;.format(S1)</span>
<span class="c">#print &#39;S2: {0}&#39;.format(S2)</span>
</pre></div>
</div>
<div class="highlight-none"><div class="highlight"><pre>---------------------
optimization problem  (SDP):
210 variables, 20 affine constraints, 210 vars in 1 SD cones

X   : (20, 20), symmetric

        maximize 〈 L | X 〉
such that
diag(X) = |1|
X ≽ |0|
---------------------
bound from the SDP relaxation: 478.2074...
value of the cut: 471.0
</pre></div>
</div>
<p>Let us now draw this cut:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#display the cut</span>
<span class="kn">import</span> <span class="nn">pylab</span>

<span class="n">fig</span><span class="o">=</span><span class="n">pylab</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span>

<span class="n">pos</span><span class="o">=</span><span class="n">nx</span><span class="o">.</span><span class="n">spring_layout</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

<span class="n">node_colors</span><span class="o">=</span><span class="p">[(</span><span class="s">&#39;g&#39;</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">S1</span> <span class="k">else</span> <span class="s">&#39;b&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">edgelist</span><span class="o">=</span><span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cut</span><span class="p">],</span>
                <span class="n">node_color</span><span class="o">=</span><span class="n">node_colors</span><span class="p">)</span>

<span class="n">nx</span><span class="o">.</span><span class="n">draw_networkx_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">pos</span><span class="p">,</span>
                <span class="n">edgelist</span><span class="o">=</span><span class="n">cut</span><span class="p">,</span>
                <span class="n">edge_color</span><span class="o">=</span><span class="s">&#39;r&#39;</span><span class="p">)</span>

<span class="c">#hide axis</span>
<span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_xaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>
<span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">get_yaxis</span><span class="p">()</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">([])</span>

<span class="n">pylab</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="./pyplots/maxcut.py">Source code</a>, <a class="reference external" href="./pyplots/maxcut.png">png</a>, <a class="reference external" href="./pyplots/maxcut.hires.png">hires.png</a>, <a class="reference external" href="./pyplots/maxcut.pdf">pdf</a>)</p>
<div class="figure">
<img alt="_images/maxcut.png" src="_images/maxcut.png" />
</div>
<p>On this graph, the red edges are those defining the cut, and the nodes
are blue or green depending on the partition they belong to.</p>
</div>
<div class="section" id="references">
<span id="graph-refs"></span><h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ol class="arabic simple">
<li>&#8220;Maximal Flow through a Network&#8221;, LR Ford Jr and DR Fulkerson,
<em>Canadian journal of mathematics</em>, 1956.</li>
<li>&#8220;Analysis of LP relaxations for multiway and multicut problems&#8221;,
D.Bertsimas, C.P. Teo and R. Vohra,
<em>Networks</em>, 34(2), p. <em>102-114</em>, 1999.</li>
<li>&#8220;Improved approximation algorithms for maximum cut and satisfiability problems using semidefinite programming&#8221;,
M.X. Goemans and D.P. Williamson,
<em>Journal of the ACM</em>, 42(6), p. <em>1115-1145</em>, 1995.</li>
</ol>
</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h3><a href="index.html">Table Of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="tuto.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="examples.html">Examples</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="optdes.html">Examples from Optimal Experimental Design</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="">Cut problems in graphs</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api.html">The PICOS Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="download.html">Download</a></li>
</ul>

  <h3><a href="index.html">Contents of this page</a></h3>
  <ul>
<li><a class="reference internal" href="#">Cut problems in graphs</a><ul>
<li><a class="reference internal" href="#max-flow-min-cut-lp">Max-flow, Min-cut (LP)</a><ul>
<li><a class="reference internal" href="#max-flow">Max-flow</a></li>
<li><a class="reference internal" href="#min-cut">Min-cut</a></li>
</ul>
</li>
<li><a class="reference internal" href="#multicut-mip">Multicut (MIP)</a></li>
<li><a class="reference internal" href="#maxcut-relaxation-sdp">Maxcut relaxation (SDP)</a></li>
<li><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="optdes.html"
                        title="previous chapter">Examples from Optimal Experimental Design</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="api.html"
                        title="next chapter">The PICOS Reference</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/graphs.txt"
           rel="nofollow">Show Source</a></li>
  </ul>

  <h3><a href="download.html">Download</a></h3>
  <ul class="this-page-menu">
    <li><a href="dist/PICOS-0.1.3.tar.gz" onClick="javascript: _gaq.push(['_trackPageview', '/downloads/version013']);" onClick="javascript: _gaq.push(['_trackPageview', '/downloads/version013']);">Latest Version (0.1.3)</a></li>
  </ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api.html" title="The PICOS Reference"
             >next</a> |</li>
        <li class="right" >
          <a href="optdes.html" title="Examples from Optimal Experimental Design"
             >previous</a> |</li>
        <li><a href="index.html">PICOS</a> &raquo;</li>
          <li><a href="examples.html" >Examples</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Guillaume Sagnol.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>